
## Difficulty: Hard

### Challenge Info:
An obvious contender for GOTY, in 1998...

**Author:** Tsuto  
**Package Link:** [Super Gameboy.gb](https://github.com/CyberSauce001/DoD-Cyber-Sentinel-Challenge/blob/main/Malware%20%26%20Reverse%20Engineering/Packages/SuperSecretAdventure.gb)

You can use any Game Boy emulator to run the game provided in the package link. We recommend using SameBoy (since it has a debugger).

Upon launching the game, you can move and explore around the room. You can interact with the object in the middle of the room. Clicking on it reveals a flag and an encrypted message, likely indicating the flag needed to solve this challenge.

Looking around, you see a wizard in the lower right corner. When interacting with him, he gives you a clue: the word `bEDiPbtzXgmL` and a hint to use hex to solve it. Upon finding the answer, you can return to the wizard and enter an 8-character hex code to solve the puzzle.

First, we need to use Ghidra. You will need to install some extensions or additional packages to work with Game Boy files. Download the 'Ghidra boy plugin' or something similar that can parse Game Boy games.

Upon opening the file, you will see registers, hex codes, etc. If you are not familiar with it, take it step by step. If you know some coding, you can figure out there is a loop in the decompiler -> `do { if() else if()}`. This is likely the wizard's loop function, as he repeats the same dialogue until you enter the correct hex code. Clicking and inspecting each function, you will see what they do. You can also rename the functions to make it easier.

*Note: You can see the hex next to the dialog string.*

Upon inspecting, you should notice that `char FUN_17e1(void)` has a statement in its loop: `cVar1 = printf(0x44, "Wow! I felt a  ");`. (I replaced fun_131c with printf to make it readable). This line shows us that entering the correct hex code leads to the wizard saying this. Let’s track down where else it is mentioned. Clicking on `DAT_cff5`, we are taken to the left side of the Ghidra column. Scrolling a bit more to the right, we see `DAT_cff5` is reading, writing, and executing. We only care about the writing. Clicking on the first write function `FUN_1557:1646(W)` takes us to the statement:

```c
if cVar1 == '\x01') { DAT_cff5 == 3 }
```

This is what we are looking for. We also see `cVar1 = FUN_13a4()`, checking if the answer is correct.

Clicking on `FUN_13a4` brings us to a huge function. Within it, there are a few things to note. Let’s look at the variables `byte local_10c & local_108`. These variables seem to accept arrays of 4 bytes and 256 bytes. Below, `byte local_10c` is assigned to `local_4`, which checks if the answer is correct. We see:

```c
local_4 == local_8
```

If `local_4` (check value) equals `local_8` (input value), the condition is true. If so, it loads the input into `local_108`.


Going back to `check_value = local_10c[0];`, we click on the variable to see it called at `13b2 cd 24 0c`. Next, launch a debugger to retrieve the value going into the registry.

Type:
```sh
i
```
to interrupt and create the first breakpoint at the wizard, where you are about to enter the code. Then go to the line we want:
```sh
b $13b5
```
This creates a breakpoint below the CALL function `FUN_0c24`. Press `c` to continue through the breakpoint. From the emulator, submit the input to retrieve the value where the stack pointer is storing the registry value. Press `r` to retrieve the data. The Stack Pointer (SP) = $deea, where it is loading the answer. Type:
```sh
ex $deea
```
to show the bytes of deea. The first few bytes will pop off the stack into the register. Press `c` to continue. Talk to the wizard again and input the first 8 bytes: `6b 8a 80 a6`. Press `c` in the debugger, and the wizard text changes.

Going back to the podium and clicking on it reveals the flag:


**Flag:** 
```
C1{RC4_1s_m4G1c}

```
